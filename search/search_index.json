{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"api/aop/","title":"AOP Module","text":"<p>The AOP module gives you the possibility to define aspects that will participate in method execution flows.</p> <p>Example: all method executions of methods named \"foo\" will include a <code>before</code> aspect, that will be executed before the original method</p> <pre><code>@advice\nclass Advice:\n   @before(methods().named(\"foo\"))\n   def before_call(self, invocation: Invocation):\n      ...\n</code></pre> <p>Note, that this requires that both the advice and the targeted methods need to be managed by an environment.</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget","title":"<code>AspectTarget()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>AspectTarget defines the target for an aspect. It can be used to specify the class, method, and conditions under which the aspect should be applied. It supports matching by class type, method name, patterns, decorators, and more.</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.decorated_with","title":"<code>decorated_with(decorator)</code>","text":"<p>matches methods or classes that are decorated with the specified decorator</p> <p>Parameters:</p> Name Type Description Default <code>decorator</code> <code>Callable</code> <p>the decorator callable</p> required <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.matches","title":"<code>matches(pattern)</code>","text":"<p>Matches the target against a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>the pattern</p> required <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.named","title":"<code>named(name)</code>","text":"<p>Matches the target against a name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name</p> required <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.of_type","title":"<code>of_type(type)</code>","text":"<p>matches methods belonging to a class or classes that are subclasses of the specified type</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Type</code> <p>the type to match against</p> required <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.that_are_async","title":"<code>that_are_async()</code>","text":"<p>matches methods that are async</p> <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.AspectTarget.that_are_sync","title":"<code>that_are_sync()</code>","text":"<p>matches methods that are sync</p> <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>AspectTarget</code> <p>self</p>"},{"location":"api/aop/#aspyx.di.aop.Invocation","title":"<code>Invocation(func, aspects)</code>","text":"<p>Invocation stores the relevant data of a single method invocation. It holds the arguments, keyword arguments, result, error, and the aspects that define the aspect behavior.</p>"},{"location":"api/aop/#aspyx.di.aop.Invocation.proceed","title":"<code>proceed(*args, **kwargs)</code>","text":"<p>Proceed to the next aspect in the around chain up to the original method.</p>"},{"location":"api/aop/#aspyx.di.aop.Invocation.proceed_async","title":"<code>proceed_async(*args, **kwargs)</code>  <code>async</code>","text":"<p>Proceed to the next aspect in the around chain up to the original method.</p>"},{"location":"api/aop/#aspyx.di.aop.advice","title":"<code>advice(cls)</code>","text":"<p>Classes decorated with <code>@advice</code> are treated as advice classes. They can contain methods decorated with <code>@before</code>, <code>@after</code>, <code>@around</code>, or <code>@error</code> to define aspects.</p>"},{"location":"api/aop/#aspyx.di.aop.after","title":"<code>after(*targets)</code>","text":"<p>Methods decorated with <code>@after</code> will be executed after the target method is invoked.</p>"},{"location":"api/aop/#aspyx.di.aop.around","title":"<code>around(*targets)</code>","text":"<p>Methods decorated with <code>@around</code> will be executed around the target method. Every around method must accept a single parameter of type Invocation and needs to call proceed on this parameter to proceed to the next around method.</p>"},{"location":"api/aop/#aspyx.di.aop.before","title":"<code>before(*targets)</code>","text":"<p>Methods decorated with <code>@before</code> will be executed before the target method is invoked.</p>"},{"location":"api/aop/#aspyx.di.aop.classes","title":"<code>classes()</code>","text":"<p>Create a new AspectTarget instance to define class aspect targets.</p> <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>ClassAspectTarget</code> <p>the method target</p>"},{"location":"api/aop/#aspyx.di.aop.error","title":"<code>error(*targets)</code>","text":"<p>Methods decorated with <code>@error</code> will be executed if the target method raises an exception.</p>"},{"location":"api/aop/#aspyx.di.aop.methods","title":"<code>methods()</code>","text":"<p>Create a new AspectTarget instance to define method aspect targets.</p> <p>Returns:</p> Name Type Description <code>AspectTarget</code> <code>MethodAspectTarget</code> <p>the method target</p>"},{"location":"api/auzhorization/","title":"Authorization Module","text":"<p>authorization logic</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AbstractAuthorizationFactory","title":"<code>AbstractAuthorizationFactory()</code>","text":"<p>               Bases: <code>AuthorizationFactory</code></p> <p>Abstract base class for authorization factories</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager","title":"<code>AuthorizationManager()</code>","text":"<p>The authorization manager is used to remember and execute pluggable authorization checks.</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager.Authorization","title":"<code>Authorization</code>","text":"<p>Base class for authorization checks</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager.Authorization.authorize","title":"<code>authorize(invocation)</code>","text":"<p>execute the authorization check. Throws an exception in case of violations</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager.AuthorizationFactory","title":"<code>AuthorizationFactory(order=0)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An authorization factory is used to create possible authorization checks given a method descriptor</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager.AuthorizationFactory.compute_authorization","title":"<code>compute_authorization(method_descriptor)</code>  <code>abstractmethod</code>","text":"<p>return a possible authorization check given a method descriptor Args:     method_descriptor: the corresponding method descriptor</p> <p>Returns:</p> Type Description <code>Optional[Authorization]</code> <p>an authorization check or None</p>"},{"location":"api/auzhorization/#aspyx_service.authorization.AuthorizationManager.get_checks","title":"<code>get_checks(func)</code>","text":"<p>return a list of authorization checks given a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>the corresponding function.</p> required <p>Returns:</p> Type Description <code>list[Authorization]</code> <p>list of authorization checks</p>"},{"location":"api/channels/","title":"Channels","text":"<p>Service management and dependency injection framework.</p> <p>Protobuf channel and utilities</p>"},{"location":"api/channels/#aspyx_service.channels.DispatchJSONChannel","title":"<code>DispatchJSONChannel()</code>","text":"<p>               Bases: <code>HTTPXChannel</code></p> <p>A channel that calls a POST on the endpoint <code>\u00ecnvoke</code> sending a request body containing information on the called component, service and method and the arguments.</p>"},{"location":"api/channels/#aspyx_service.channels.DispatchMSPackChannel","title":"<code>DispatchMSPackChannel()</code>","text":"<p>               Bases: <code>HTTPXChannel</code></p> <p>A channel that sends a POST on the \u00ecnvoke <code>endpoint</code>with an msgpack encoded request body.</p>"},{"location":"api/channels/#aspyx_service.channels.HTTPXChannel","title":"<code>HTTPXChannel()</code>","text":"<p>               Bases: <code>Channel</code></p> <p>A channel using the httpx clients.</p>"},{"location":"api/channels/#aspyx_service.channels.TokenContext","title":"<code>TokenContext</code>","text":"<p>TokeContext covers two context locals for both the access and - optional - refresh topen</p>"},{"location":"api/channels/#aspyx_service.protobuf.ProtobufBuilder","title":"<code>ProtobufBuilder()</code>","text":"<p>used to infer protobuf services and messages given component and service structures.</p>"},{"location":"api/channels/#aspyx_service.protobuf.ProtobufBuilder.to_proto_type","title":"<code>to_proto_type(module_origin, py_type)</code>","text":"<p>Convert Python type to protobuf (field_type, label, type_name). Returns:     - field_type: int (descriptor_pb2.FieldDescriptorProto.TYPE_)     - label: int (descriptor_pb2.FieldDescriptorProto.LABEL_)     - type_name: Optional[str] (fully qualified message name for messages)</p>"},{"location":"api/channels/#aspyx_service.protobuf.ProtobufChannel","title":"<code>ProtobufChannel(manager, protobuf_manager)</code>","text":"<p>               Bases: <code>HTTPXChannel</code></p> <p>channel, encoding requests and responses with protobuf</p>"},{"location":"api/channels/#aspyx_service.protobuf.get_inner_type","title":"<code>get_inner_type(typ)</code>","text":"<p>Extract the inner type from List[InnerType], Optional[InnerType], etc.</p>"},{"location":"api/configuration/","title":"Configuration Module","text":"<p>This module contains functionality to read configuration values from different sources and to retrieve or inject them.</p>"},{"location":"api/configuration/#aspyx.di.configuration.ConfigurationManager","title":"<code>ConfigurationManager()</code>","text":"<p>ConfigurationManager is responsible for managing different configuration sources by merging the different values and offering a uniform api.</p>"},{"location":"api/configuration/#aspyx.di.configuration.ConfigurationManager.get","title":"<code>get(path, type, default=None)</code>","text":"<p>Retrieve a configuration value by path and type, with optional coercion.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the configuration value, e.g. \"database.host\".</p> required <code>type</code> <code>Type[T]</code> <p>The expected type.</p> required <code>default</code> <code>Optional[T]</code> <p>The default value to return if the path is not found.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The configuration value coerced to the specified type, or the default value if not found.</p>"},{"location":"api/configuration/#aspyx.di.configuration.ConfigurationSource","title":"<code>ConfigurationSource</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A configuration source is a provider of configuration data.</p>"},{"location":"api/configuration/#aspyx.di.configuration.ConfigurationSource.load","title":"<code>load()</code>  <code>abstractmethod</code>","text":"<p>return the configuration values of this source as a dictionary.</p>"},{"location":"api/configuration/#aspyx.di.configuration.EnvConfigurationSource","title":"<code>EnvConfigurationSource</code>","text":"<p>               Bases: <code>ConfigurationSource</code></p> <p>EnvConfigurationSource loads all environment variables.</p>"},{"location":"api/configuration/#aspyx.di.configuration.YamlConfigurationSource","title":"<code>YamlConfigurationSource(file)</code>","text":"<p>               Bases: <code>ConfigurationSource</code></p> <p>YamlConfigurationSource loads variables from a YAML configuration file.</p>"},{"location":"api/configuration/#aspyx.di.configuration.inject_value","title":"<code>inject_value(key, default=None)</code>","text":"<p>Decorator to inject a configuration value into a method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The configuration key to inject.</p> required <code>default</code> <p>The default value to use if the key is not found.</p> <code>None</code>"},{"location":"api/di/","title":"DI Module","text":"<p>The dependency injection module provides a framework for managing dependencies and lifecycle of objects in Python applications.</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider","title":"<code>AbstractInstanceProvider</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>An AbstractInstanceProvider is responsible to create instances.</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.create","title":"<code>create(environment, *args)</code>  <code>abstractmethod</code>","text":"<p>Create a new instance.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>the Environment</p> required <code>*args</code> <p>the required arguments</p> <code>()</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>the instance</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>return the types that i depend on ( for constructor or setter injection  ). The second tuple element is the number of parameters that a construction injection will require</p> <p>Returns:</p> Type Description <code>(list[Type], int)</code> <p>the type array and the number of parameters</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.get_host","title":"<code>get_host()</code>","text":"<p>return the class which is responsible for creation ( e.g. the injectable class )</p> <p>Returns:</p> Type Description <code>Type[T]</code> <p>Type[T]: the class which is responsible for creation</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.get_module","title":"<code>get_module()</code>  <code>abstractmethod</code>","text":"<p>return the module name of the provider</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the module name of the provider</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.get_scope","title":"<code>get_scope()</code>  <code>abstractmethod</code>","text":"<p>return the scope name</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the scope name</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.get_type","title":"<code>get_type()</code>  <code>abstractmethod</code>","text":"<p>return the type of the created instance</p> <p>Returns:</p> Type Description <code>Type[T]</code> <p>Type[T: the type]</p>"},{"location":"api/di/#aspyx.di.di.AbstractInstanceProvider.is_eager","title":"<code>is_eager()</code>  <code>abstractmethod</code>","text":"<p>return True, if the provider will eagerly construct instances</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>eager flag</p>"},{"location":"api/di/#aspyx.di.di.AmbiguousProvider","title":"<code>AmbiguousProvider(type, *providers)</code>","text":"<p>               Bases: <code>AbstractInstanceProvider</code></p> <p>An AmbiguousProvider covers all cases, where fetching a class would lead to an ambiguity exception.</p>"},{"location":"api/di/#aspyx.di.di.ClassInstanceProvider","title":"<code>ClassInstanceProvider(t, eager, scope='singleton')</code>","text":"<p>               Bases: <code>InstanceProvider</code></p> <p>A ClassInstanceProvider is able to create instances of type T by calling the class constructor.</p>"},{"location":"api/di/#aspyx.di.di.DIException","title":"<code>DIException(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in the injector.</p>"},{"location":"api/di/#aspyx.di.di.DIRegistrationException","title":"<code>DIRegistrationException(message)</code>","text":"<p>               Bases: <code>DIException</code></p> <p>Exception raised during the registration of dependencies.</p>"},{"location":"api/di/#aspyx.di.di.DIRuntimeException","title":"<code>DIRuntimeException(message)</code>","text":"<p>               Bases: <code>DIException</code></p> <p>Exception raised during the runtime.</p>"},{"location":"api/di/#aspyx.di.di.Environment","title":"<code>Environment(env, features=[], parent=None)</code>","text":"<p>Central class that manages the lifecycle of instances and their dependencies.</p> <p>Usage:</p> <pre><code>@injectable()\nclass Foo:\n    def __init__(self):\n\n@module()\nclass Module:\n    def __init__(self):\n        pass\n\nenvironment = Environment(Module)\n\nfoo = environment.get(Foo)  # will create an instance of Foo\n</code></pre> <p>Creates a new Environment instance.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Type</code> <p>The environment class that controls the scanning of managed objects.</p> required <code>parent</code> <code>Optional[Environment]</code> <p>Optional parent environment, whose objects are inherited.</p> <code>None</code>"},{"location":"api/di/#aspyx.di.di.Environment.destroy","title":"<code>destroy()</code>","text":"<p>destroy all managed instances by calling the appropriate lifecycle methods</p>"},{"location":"api/di/#aspyx.di.di.Environment.get","title":"<code>get(type)</code>","text":"<p>Create or return a cached instance for the given type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Type</code> <p>The desired type</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The requested instance</p>"},{"location":"api/di/#aspyx.di.di.Factory","title":"<code>Factory</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for factories that create instances of type T.</p>"},{"location":"api/di/#aspyx.di.di.FactoryInstanceProvider","title":"<code>FactoryInstanceProvider(factory, eager, scope)</code>","text":"<p>               Bases: <code>InstanceProvider</code></p> <p>A FactoryInstanceProvider is able to create instances of type T by calling registered Factory instances.</p>"},{"location":"api/di/#aspyx.di.di.FunctionInstanceProvider","title":"<code>FunctionInstanceProvider(clazz, method, eager=True, scope='singleton')</code>","text":"<p>               Bases: <code>InstanceProvider</code></p> <p>A FunctionInstanceProvider is able to create instances of type T by calling specific methods annotated with 'create\".</p>"},{"location":"api/di/#aspyx.di.di.InstanceProvider","title":"<code>InstanceProvider(host, t, eager, scope)</code>","text":"<p>               Bases: <code>AbstractInstanceProvider</code></p> <p>An InstanceProvider is able to create instances of type T.</p>"},{"location":"api/di/#aspyx.di.di.Lifecycle","title":"<code>Lifecycle</code>","text":"<p>               Bases: <code>Enum</code></p> <p>This enum defines the lifecycle phases that can be processed by lifecycle processors. Phases are:</p> <ul> <li>ON_INJECT</li> <li>ON_INIT</li> <li>ON_RUNNING</li> <li>ON_DESTROY</li> </ul>"},{"location":"api/di/#aspyx.di.di.LifecycleProcessor","title":"<code>LifecycleProcessor()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A LifecycleProcessor is used to perform any side effects on managed objects during different lifecycle phases.</p>"},{"location":"api/di/#aspyx.di.di.PostProcessor","title":"<code>PostProcessor()</code>","text":"<p>               Bases: <code>LifecycleProcessor</code></p> <p>Base class for custom post processors that are executed after object creation.</p>"},{"location":"api/di/#aspyx.di.di.Providers","title":"<code>Providers</code>","text":"<p>The Providers class is a static class used in the context of the registration and resolution of InstanceProviders.</p>"},{"location":"api/di/#aspyx.di.di.create","title":"<code>create(eager=True, scope='singleton')</code>","text":"<p>Any method annotated with @create will be registered as a factory method.</p> <p>Parameters:</p> Name Type Description Default <code>eager</code> <code>bool</code> <p>If True, the corresponding object will be created eagerly when the environment is created.</p> <code>True</code> <code>scope</code> <code>str</code> <p>The scope of the factory, e.g. \"singleton\", \"request\", \"environment\".</p> <code>'singleton'</code>"},{"location":"api/di/#aspyx.di.di.factory","title":"<code>factory(eager=True, scope='singleton')</code>","text":"<p>Decorator that needs to be used on a class that implements the Factory interface.</p> <p>Parameters:</p> Name Type Description Default <code>eager</code> <code>bool</code> <p>If True, the corresponding object will be created eagerly when the environment is created.</p> <code>True</code> <code>scope</code> <code>str</code> <p>The scope of the factory, e.g. \"singleton\", \"request\", \"environment\".</p> <code>'singleton'</code>"},{"location":"api/di/#aspyx.di.di.inject","title":"<code>inject()</code>","text":"<p>Methods annotated with @inject will be called with the required dependencies injected.</p>"},{"location":"api/di/#aspyx.di.di.inject_environment","title":"<code>inject_environment()</code>","text":"<p>Methods annotated with @inject_environment will be called with the Environment instance injected.</p>"},{"location":"api/di/#aspyx.di.di.injectable","title":"<code>injectable(eager=True, scope='singleton')</code>","text":"<p>Instances of classes that are annotated with @injectable can be created by an Environment.</p>"},{"location":"api/di/#aspyx.di.di.module","title":"<code>module(imports=None)</code>","text":"<p>This annotation is used to mark classes that control the discovery process of injectables based on their location relative to the module of the class. All <code>@injectable</code>s and <code>@factory</code>s that are located in the same or any sub-module will be registered and managed accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Optional[list[Type]]</code> <p>Optional list of imported module types</p> <code>None</code>"},{"location":"api/di/#aspyx.di.di.on_destroy","title":"<code>on_destroy()</code>","text":"<p>Methods annotated with <code>@on_destroy</code> will be called when the instance is destroyed.</p>"},{"location":"api/di/#aspyx.di.di.on_init","title":"<code>on_init()</code>","text":"<p>Methods annotated with <code>@on_init</code> will be called when the instance is created.</p>"},{"location":"api/di/#aspyx.di.di.on_running","title":"<code>on_running()</code>","text":"<p>Methods annotated with <code>@on_running</code> will be called when the container up and running.</p>"},{"location":"api/event/","title":"Event","text":"<p>This module provides the core Aspyx event management framework .</p> <p>stomp</p>"},{"location":"api/event/#aspyx_event.AbstractEnvelopePipeline","title":"<code>AbstractEnvelopePipeline(envelope_handler=None)</code>","text":"<p>               Bases: <code>EnvelopePipeline</code></p> <p>abstract base-class for envelope pipelines</p>"},{"location":"api/event/#aspyx_event.EventListener","title":"<code>EventListener</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An <code>EventListener</code> listens to a single event.</p>"},{"location":"api/event/#aspyx_event.EventListener.on","title":"<code>on(event)</code>","text":"<p>Callback when an event occurs.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>T</code> <p>the event</p> required"},{"location":"api/event/#aspyx_event.EventManager","title":"<code>EventManager(provider, exception_manager=None)</code>","text":"<p>Central class that manages sending and receiving/dispatching events.</p> <p>create a new <code>EventManager</code></p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Provider</code> <p>an <code>EventManager.Provider</code></p> required"},{"location":"api/event/#aspyx_event.EventManager.Envelope","title":"<code>Envelope(event=None)</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Wrapper around an event while being received or sent.</p>"},{"location":"api/event/#aspyx_event.EventManager.Envelope.get","title":"<code>get(key)</code>  <code>abstractmethod</code>","text":"<p>retrieve a header value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>a key</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the value</p>"},{"location":"api/event/#aspyx_event.EventManager.Envelope.set","title":"<code>set(key, value)</code>  <code>abstractmethod</code>","text":"<p>set a header value</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>a key</p> required <code>value</code> <code>str</code> <p>the value</p> required"},{"location":"api/event/#aspyx_event.EventManager.EnvelopePipeline","title":"<code>EnvelopePipeline</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An interceptor for sending and receiving events</p>"},{"location":"api/event/#aspyx_event.EventManager.EnvelopePipeline.handle","title":"<code>handle(envelope, event_listener_descriptor)</code>  <code>abstractmethod</code>","text":"<p>interceptor on the handling side Args:     envelope: the envelope     event_listener_descriptor: the listener descriptor</p>"},{"location":"api/event/#aspyx_event.EventManager.EnvelopePipeline.send","title":"<code>send(envelope, event_descriptor)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>interceptor on the sending side Args:     envelope: the envelope     event_descriptor: the event descriptor</p>"},{"location":"api/event/#aspyx_event.EventManager.EventDescriptor","title":"<code>EventDescriptor(type)</code>","text":"<p>Covers the meta-data of an event.</p>"},{"location":"api/event/#aspyx_event.EventManager.EventListenerDescriptor","title":"<code>EventListenerDescriptor(type, event_type, name, group, per_process)</code>","text":"<p>Covers the meta-data of an event listener.</p>"},{"location":"api/event/#aspyx_event.EventManager.Provider","title":"<code>Provider(envelope_factory)</code>","text":"<p>               Bases: <code>EnvelopePipeline</code></p> <p>The bridge to a low-level queuing library.</p>"},{"location":"api/event/#aspyx_event.EventManager.send_event","title":"<code>send_event(event)</code>  <code>async</code>","text":"<p>send an event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Any</code> <p>the event</p> required"},{"location":"api/event/#aspyx_event.envelope_pipeline","title":"<code>envelope_pipeline()</code>","text":"<p>decorates an envelope pipeline</p>"},{"location":"api/event/#aspyx_event.event_listener","title":"<code>event_listener(event, name='', group='', per_process=False)</code>","text":"<p>decorates event listeners.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Type</code> <p>the event type</p> required <code>name</code> <p>the listener name</p> <code>''</code> <code>per_process</code> <p>if <code>True</code>, listeners will process events on different processes</p> <code>False</code> <p>Returns:</p>"},{"location":"api/exception/","title":"Exception Module","text":"<p>This module provides exception handling functions.</p>"},{"location":"api/exception/#aspyx.exception.ExceptionManager","title":"<code>ExceptionManager()</code>","text":"<p>An exception manager collects all registered handlers and is able to handle an exception by dispatching it to the most applicable handler ( according to mro )</p>"},{"location":"api/exception/#aspyx.exception.ExceptionManager.handle","title":"<code>handle(exception)</code>","text":"<p>handle an exception by invoking the most applicable handler (according to mro) and return a possible modified exception as a result.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>BaseException</code> <p>the exception</p> required <p>Returns:</p> Name Type Description <code>BaseException</code> <code>BaseException</code> <p>the resulting - possible transformed - exception</p>"},{"location":"api/exception/#aspyx.exception.ExceptionManager.proceed","title":"<code>proceed()</code>  <code>classmethod</code>","text":"<p>proceed with the next most applicable handler</p> <p>Returns:</p> Name Type Description <code>BaseException</code> <code>BaseException</code> <p>the resulting exception</p>"},{"location":"api/exception/#aspyx.exception.catch","title":"<code>catch()</code>","text":"<p>Any method annotated with @catch will be registered as an exception handler method.</p>"},{"location":"api/exception/#aspyx.exception.exception_handler","title":"<code>exception_handler()</code>","text":"<p>This annotation is used to mark classes that container handlers for exceptions</p>"},{"location":"api/exception/#aspyx.exception.handle","title":"<code>handle()</code>","text":"<p>Any method annotated with @handle will be registered as an exception handler method.</p>"},{"location":"api/healthcheck/","title":"Health Check","text":"<p>health checks</p>"},{"location":"api/healthcheck/#aspyx_service.healthcheck.HealthCheckManager","title":"<code>HealthCheckManager()</code>","text":"<p>The health manager is able to run all registered health checks and is able to return an overall status.</p>"},{"location":"api/healthcheck/#aspyx_service.healthcheck.HealthCheckManager.check","title":"<code>check()</code>  <code>async</code>","text":"<p>run all registered health checks and return an overall result. Returns: the overall result.</p>"},{"location":"api/healthcheck/#aspyx_service.healthcheck.HealthStatus","title":"<code>HealthStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum specifying the health status of a service. The values are:</p> <ul> <li><code>OK</code> service is healthy</li> <li><code>WARNING</code> service has some problems</li> <li><code>CRITICAL</code> service is unhealthy</li> </ul>"},{"location":"api/healthcheck/#aspyx_service.healthcheck.health_check","title":"<code>health_check(name='', cache=0, fail_if_slower_than=0)</code>","text":"<p>Methods annotated with <code>@health_check</code> specify health checks that will be executed.</p>"},{"location":"api/healthcheck/#aspyx_service.healthcheck.health_checks","title":"<code>health_checks()</code>","text":"<p>Instances of classes that are annotated with @health_checks contain healt mehtods.</p>"},{"location":"api/reflection/","title":"Reflection Module","text":"<p>This module provides tools for dynamic proxy creation and reflection</p>"},{"location":"api/reflection/#aspyx.reflection.DecoratorDescriptor","title":"<code>DecoratorDescriptor(decorator, *args)</code>","text":"<p>A DecoratorDescriptor covers the decorator - a callable - and the passed arguments</p>"},{"location":"api/reflection/#aspyx.reflection.Decorators","title":"<code>Decorators</code>","text":"<p>Utility class that caches decorators ( Python does not have a feature for this )</p>"},{"location":"api/reflection/#aspyx.reflection.Decorators.add","title":"<code>add(func_or_class, decorator, *args)</code>  <code>classmethod</code>","text":"<p>Remember the decorator Args:     func_or_class: a function or class     decorator: the decorator     *args: any arguments supplied to the decorator</p>"},{"location":"api/reflection/#aspyx.reflection.Decorators.get","title":"<code>get(func_or_class)</code>  <code>classmethod</code>","text":"<p>return the list of decorators associated with the given function or class Args:     func_or_class: the function or class</p> <p>Returns:</p> Type Description <code>list[DecoratorDescriptor]</code> <p>list[DecoratorDescriptor]: the list</p>"},{"location":"api/reflection/#aspyx.reflection.Decorators.has_decorator","title":"<code>has_decorator(func_or_class, callable)</code>  <code>classmethod</code>","text":"<p>Return True, if the function or class is decorated with the decorator Args:     func_or_class: a function or class     callable: the decorator</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>the result</p>"},{"location":"api/reflection/#aspyx.reflection.DynamicProxy","title":"<code>DynamicProxy(type, invocation_handler)</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>DynamicProxy enables dynamic method interception and delegation for any class type.</p> <p>It is used to create proxy objects that forward method calls to a custom InvocationHandler. This allows for advanced patterns such as aspect-oriented programming, logging, or remote invocation, by intercepting method calls at runtime and handling them as needed.</p> <p>Usage: <pre><code>    class MyHandler(DynamicProxy.InvocationHandler):\n        def invoke(self, invocation):\n            print(f\"Intercepted: {invocation.name}\")\n            # custom logic here\n            return ...\n\n    proxy = DynamicProxy.create(SomeClass, MyHandler())\n    proxy.some_method(args)  # Will be intercepted by MyHandler.invoke\n</code></pre></p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor","title":"<code>TypeDescriptor(cls)</code>","text":"<p>This class provides a way to introspect Python classes, their methods, decorators, and type hints.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor","title":"<code>MethodDescriptor(cls, method)</code>","text":"<p>This class represents a method of a class, including its decorators, parameter types, and return type.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor.get_decorator","title":"<code>get_decorator(decorator)</code>","text":"<p>return the DecoratorDescriptor - if any - associated with the passed Callable</p> <p>Parameters:</p> Name Type Description Default <code>decorator</code> <code>Callable</code> <p>the decorator</p> required <p>Returns:</p> Type Description <code>Optional[DecoratorDescriptor]</code> <p>Optional[DecoratorDescriptor]: the DecoratorDescriptor or None</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor.get_doc","title":"<code>get_doc(default='')</code>","text":"<p>return the method docstring</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <p>the default if no docstring is found</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the docstring</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor.get_name","title":"<code>get_name()</code>","text":"<p>return the method name</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the method name</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor.has_decorator","title":"<code>has_decorator(decorator)</code>","text":"<p>return True if the method is decorated with the decorator</p> <p>Parameters:</p> Name Type Description Default <code>decorator</code> <code>Callable</code> <p>the decorator callable</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the method is decorated with the decorator</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.MethodDescriptor.is_async","title":"<code>is_async()</code>","text":"<p>return true if the method is asynchronous</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>async flag</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.PropertyDescriptor","title":"<code>PropertyDescriptor(cls, name, typ=None, default=None, type_property=None)</code>","text":"<p>Describes a class property (field) \u2014 can be read and written via reflection.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.for_type","title":"<code>for_type(clazz)</code>  <code>classmethod</code>","text":"<p>Returns a TypeDescriptor for the given class, using a cache to avoid redundant introspection.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.get_decorator","title":"<code>get_decorator(decorator)</code>","text":"<p>Returns the first decorator of the given type, or None if not found.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.get_method","title":"<code>get_method(name, local=False)</code>","text":"<p>Returns a MethodDescriptor for the method with the given name. If local is True, only searches for methods defined in the class itself, otherwise includes inherited methods.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.get_methods","title":"<code>get_methods(local=False)</code>","text":"<p>Returns a list of MethodDescriptor objects for the class. If local is True, only returns methods defined in the class itself, otherwise includes inherited methods.</p>"},{"location":"api/reflection/#aspyx.reflection.TypeDescriptor.has_decorator","title":"<code>has_decorator(decorator)</code>","text":"<p>Checks if the class has a decorator of the given type.</p>"},{"location":"api/registries/","title":"Registries","text":"<p>registries for components in aspyx service</p>"},{"location":"api/registries/#aspyx_service.registries.ConsulComponentRegistry","title":"<code>ConsulComponentRegistry(port, consul)</code>","text":"<p>               Bases: <code>ComponentRegistry</code></p> <p>A specialized registry using consul. A polling mechanism is used to identify changes in the component health.</p>"},{"location":"api/server/","title":"Server","text":"<p>FastAPI server implementation for the aspyx service framework.</p> <p>health checks</p>"},{"location":"api/server/#aspyx_service.server.FastAPIServer","title":"<code>FastAPIServer(fast_api, service_manager, component_registry)</code>","text":"<p>               Bases: <code>Server</code></p> <p>A server utilizing fastapi framework.</p>"},{"location":"api/server/#aspyx_service.server.FastAPIServer.add_routes","title":"<code>add_routes()</code>","text":"<p>Add everything that looks like an HTTP endpoint</p>"},{"location":"api/server/#aspyx_service.server.FastAPIServer.boot","title":"<code>boot(module, host='0.0.0.0', port=8000, start_thread=True)</code>  <code>classmethod</code>","text":"<p>boot the DI infrastructure of the supplied module and optionally start a fastapi thread given the url Args:     module: the module to initialize the environment     host: listen address     port: the port</p> <p>Returns:</p> Type Description <code>Environment</code> <p>the created environment</p>"},{"location":"api/server/#aspyx_service.server.FastAPIServer.start_server","title":"<code>start_server(host)</code>","text":"<p>start the fastapi server in a thread</p>"},{"location":"api/server/#aspyx_service.server.RequestContext","title":"<code>RequestContext(app)</code>","text":"<p>A request context is used to remember the current http request in the current thread</p>"},{"location":"api/server/#aspyx_service.server.RequestContext.get_request","title":"<code>get_request()</code>  <code>classmethod</code>","text":"<p>Return the current http request</p> <p>Returns:</p> Type Description <code>Request</code> <p>the current http request</p>"},{"location":"api/server/#aspyx_service.healthcheck.HealthCheckManager","title":"<code>HealthCheckManager()</code>","text":"<p>The health manager is able to run all registered health checks and is able to return an overall status.</p>"},{"location":"api/server/#aspyx_service.healthcheck.HealthCheckManager.check","title":"<code>check()</code>  <code>async</code>","text":"<p>run all registered health checks and return an overall result. Returns: the overall result.</p>"},{"location":"api/server/#aspyx_service.healthcheck.HealthStatus","title":"<code>HealthStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A enum specifying the health status of a service. The values are:</p> <ul> <li><code>OK</code> service is healthy</li> <li><code>WARNING</code> service has some problems</li> <li><code>CRITICAL</code> service is unhealthy</li> </ul>"},{"location":"api/server/#aspyx_service.healthcheck.health_check","title":"<code>health_check(name='', cache=0, fail_if_slower_than=0)</code>","text":"<p>Methods annotated with <code>@health_check</code> specify health checks that will be executed.</p>"},{"location":"api/server/#aspyx_service.healthcheck.health_checks","title":"<code>health_checks()</code>","text":"<p>Instances of classes that are annotated with @health_checks contain healt mehtods.</p>"},{"location":"api/service/","title":"Service","text":"<p>service management framework allowing for service discovery and transparent remoting including multiple possible transport protocols.</p>"},{"location":"api/service/#aspyx_service.service.AbstractComponent","title":"<code>AbstractComponent()</code>","text":"<p>               Bases: <code>Component</code>, <code>ABC</code></p> <p>abstract base class for components</p>"},{"location":"api/service/#aspyx_service.service.BaseDescriptor","title":"<code>BaseDescriptor(type, decorator)</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>the base class for the meta data of both services and components.</p>"},{"location":"api/service/#aspyx_service.service.Channel","title":"<code>Channel()</code>","text":"<p>               Bases: <code>InvocationHandler</code>, <code>ABC</code></p> <p>A channel is a dynamic proxy invocation handler and transparently takes care of remoting.</p>"},{"location":"api/service/#aspyx_service.service.Channel.FirstURLSelector","title":"<code>FirstURLSelector</code>","text":"<p>               Bases: <code>URLSelector</code></p> <p>a url selector always retrieving the first URL given a list of possible URLS</p>"},{"location":"api/service/#aspyx_service.service.Channel.RoundRobinURLSelector","title":"<code>RoundRobinURLSelector()</code>","text":"<p>               Bases: <code>URLSelector</code></p> <p>a url selector that picks urls sequentially given a list of possible URLS</p>"},{"location":"api/service/#aspyx_service.service.Channel.URLSelector","title":"<code>URLSelector</code>","text":"<p>a url selector retrieves a URL for the next remoting call.</p>"},{"location":"api/service/#aspyx_service.service.Channel.URLSelector.get","title":"<code>get(urls)</code>  <code>abstractmethod</code>","text":"<p>return the next URL given a list of possible URLS</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list[str]</code> <p>list of possible URLS</p> required <p>Returns:</p> Type Description <code>str</code> <p>a URL</p>"},{"location":"api/service/#aspyx_service.service.Channel.select_first_url","title":"<code>select_first_url()</code>","text":"<p>pick the first URL</p>"},{"location":"api/service/#aspyx_service.service.Channel.select_round_robin","title":"<code>select_round_robin()</code>","text":"<p>enable round robin</p>"},{"location":"api/service/#aspyx_service.service.ChannelAddress","title":"<code>ChannelAddress(channel, uri)</code>  <code>dataclass</code>","text":"<p>A channel address is a combination of:</p> <ul> <li>channel: the channel name</li> <li>uri: uri of the appropriate endpoint</li> </ul>"},{"location":"api/service/#aspyx_service.service.ChannelFactory","title":"<code>ChannelFactory()</code>","text":"<p>Internal factory for channels.</p>"},{"location":"api/service/#aspyx_service.service.ChannelInstances","title":"<code>ChannelInstances(component, channel, urls=[])</code>  <code>dataclass</code>","text":"<p>a resolved channel address containing:</p> <ul> <li>component: the component name</li> <li>channel: the channel name</li> <li>urls: list of URLs</li> </ul>"},{"location":"api/service/#aspyx_service.service.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>Service</code></p> <p>This is the base class for components.</p>"},{"location":"api/service/#aspyx_service.service.Component.get_addresses","title":"<code>get_addresses(port)</code>  <code>abstractmethod</code>","text":"<p>returns a list of channel addresses that expose this component's services.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>the port of a server hosting this component</p> required <p>Returns:</p> Type Description <code>list[ChannelAddress]</code> <p>list of channel addresses</p>"},{"location":"api/service/#aspyx_service.service.Component.get_health","title":"<code>get_health()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>return the component health</p> <p>Returns: the component health</p>"},{"location":"api/service/#aspyx_service.service.Component.get_status","title":"<code>get_status()</code>  <code>abstractmethod</code>","text":"<p>return the component status callback</p> <p>Returns: the component status</p>"},{"location":"api/service/#aspyx_service.service.Component.shutdown","title":"<code>shutdown()</code>  <code>abstractmethod</code>","text":"<p>shutdown callback</p>"},{"location":"api/service/#aspyx_service.service.Component.startup","title":"<code>startup()</code>  <code>abstractmethod</code>","text":"<p>startup callback</p>"},{"location":"api/service/#aspyx_service.service.ComponentDescriptor","title":"<code>ComponentDescriptor(component_type, service_types)</code>","text":"<p>               Bases: <code>BaseDescriptor[T]</code></p> <p>meta data for components</p>"},{"location":"api/service/#aspyx_service.service.ComponentRegistry","title":"<code>ComponentRegistry</code>","text":"<p>A component registry keeps track of components including their health</p>"},{"location":"api/service/#aspyx_service.service.ComponentRegistry.deregister","title":"<code>deregister(descriptor)</code>  <code>abstractmethod</code>","text":"<p>deregister a component from the registry Args:     descriptor: the component descriptor</p>"},{"location":"api/service/#aspyx_service.service.ComponentRegistry.get_addresses","title":"<code>get_addresses(descriptor)</code>  <code>abstractmethod</code>","text":"<p>return a list of addresses that can be used to call services belonging to this component</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <code>ComponentDescriptor</code> <p>the component descriptor</p> required <p>Returns:</p> Type Description <code>list[ChannelInstances]</code> <p>list of channel instances</p>"},{"location":"api/service/#aspyx_service.service.ComponentRegistry.register","title":"<code>register(descriptor, addresses)</code>  <code>abstractmethod</code>","text":"<p>register a component to the registry Args:     descriptor: the descriptor     addresses: list of addresses</p>"},{"location":"api/service/#aspyx_service.service.ComponentRegistry.watch","title":"<code>watch(channel)</code>  <code>abstractmethod</code>","text":"<p>remember the passed channel and keep it informed about address changes Args:     channel: a channel</p>"},{"location":"api/service/#aspyx_service.service.ComponentStatus","title":"<code>ComponentStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A component is in one of the following statuses:</p> <ul> <li>VIRGIN: just constructed</li> <li>RUNNING: registered and up and running</li> <li>STOPPED: after shutdown</li> </ul>"},{"location":"api/service/#aspyx_service.service.LocalServiceException","title":"<code>LocalServiceException</code>","text":"<p>               Bases: <code>ServiceException</code></p> <p>base class for service exceptions occurring locally</p>"},{"location":"api/service/#aspyx_service.service.RemoteServiceException","title":"<code>RemoteServiceException</code>","text":"<p>               Bases: <code>ServiceException</code></p> <p>base class for service exceptions occurring on the server side</p>"},{"location":"api/service/#aspyx_service.service.Server","title":"<code>Server()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A server is a central class that boots a main module and initializes the ServiceManager. It also is the place where http servers get initialized.</p>"},{"location":"api/service/#aspyx_service.service.Server.get_local_ip","title":"<code>get_local_ip()</code>  <code>classmethod</code>","text":"<p>return the local ip address</p> <p>Returns: the local ip address</p>"},{"location":"api/service/#aspyx_service.service.Service","title":"<code>Service</code>","text":"<p>This is something like a 'tagging interface' for services.</p>"},{"location":"api/service/#aspyx_service.service.ServiceCommunicationException","title":"<code>ServiceCommunicationException</code>","text":"<p>               Bases: <code>ServiceException</code></p> <p>base class for service exceptions thrown by remoting errors</p>"},{"location":"api/service/#aspyx_service.service.ServiceDescriptor","title":"<code>ServiceDescriptor(component_descriptor, service_type)</code>","text":"<p>               Bases: <code>BaseDescriptor[T]</code></p> <p>meta data for services</p>"},{"location":"api/service/#aspyx_service.service.ServiceException","title":"<code>ServiceException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>base class for service exceptions</p>"},{"location":"api/service/#aspyx_service.service.ServiceInstanceProvider","title":"<code>ServiceInstanceProvider(clazz)</code>","text":"<p>               Bases: <code>InstanceProvider</code></p> <p>A ServiceInstanceProvider is able to create instances of services.</p>"},{"location":"api/service/#aspyx_service.service.ServiceManager","title":"<code>ServiceManager(component_registry, channel_factory)</code>","text":"<p>Central class that manages services and components and is able to return proxies.</p>"},{"location":"api/service/#aspyx_service.service.ServiceManager.get_service","title":"<code>get_service(service_type, preferred_channel='')</code>","text":"<p>return a service proxy given a service type and preferred channel name</p> <p>Parameters:</p> Name Type Description Default <code>service_type</code> <code>Type[T]</code> <p>the service type</p> required <code>preferred_channel</code> <p>the preferred channel name</p> <code>''</code> <p>Returns:</p> Type Description <code>T</code> <p>the proxy</p>"},{"location":"api/service/#aspyx_service.service.channel","title":"<code>channel(name)</code>","text":"<p>this decorator is used to mark channel implementations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the channel name</p> required"},{"location":"api/service/#aspyx_service.service.component","title":"<code>component(name='', description='', services=[])</code>","text":"<p>decorates component interfaces</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>the component name. If empty the class name converted to snake-case is used</p> <code>''</code> <code>description</code> <p>optional description</p> <code>''</code> <code>services</code> <code>list[Type]</code> <p>the list of hosted services</p> <code>[]</code>"},{"location":"api/service/#aspyx_service.service.health","title":"<code>health(endpoint='')</code>","text":"<p>specifies the health endpoint that will return the component health</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <p>the  health endpoint</p> <code>''</code>"},{"location":"api/service/#aspyx_service.service.implementation","title":"<code>implementation()</code>","text":"<p>decorates service or component implementations.</p>"},{"location":"api/service/#aspyx_service.service.service","title":"<code>service(name='', description='')</code>","text":"<p>decorates service interfaces</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>the service name. If empty the class name converted to snake case is used</p> <code>''</code> <code>description</code> <p>optional description</p> <code>''</code>"},{"location":"api/session/","title":"Session Module","text":"<p>session related module</p>"},{"location":"api/session/#aspyx_service.session.Session","title":"<code>Session()</code>","text":"<p>Base class for objects covers data related to a server side session.</p>"},{"location":"api/session/#aspyx_service.session.SessionContext","title":"<code>SessionContext</code>","text":""},{"location":"api/session/#aspyx_service.session.SessionContext.clear","title":"<code>clear()</code>  <code>classmethod</code>","text":"<p>delete the current session</p>"},{"location":"api/session/#aspyx_service.session.SessionContext.get","title":"<code>get(type)</code>  <code>classmethod</code>","text":"<p>return the current session associated with the context Args:     type:  the session type</p> <p>Returns:</p> Type Description <code>T</code> <p>the current session</p>"},{"location":"api/session/#aspyx_service.session.SessionContext.set","title":"<code>set(session)</code>  <code>classmethod</code>","text":"<p>set the current session in the context Args:     session: the session</p>"},{"location":"api/session/#aspyx_service.session.SessionManager","title":"<code>SessionManager(storage)</code>","text":"<p>               Bases: <code>SessionContext</code></p> <p>A SessionManager controls the lifecycle of sessions and is responsible to establish a session context local.</p>"},{"location":"api/session/#aspyx_service.session.SessionManager.InMemoryStorage","title":"<code>InMemoryStorage(max_size=1000, ttl=3600)</code>","text":"<p>               Bases: <code>Storage</code></p> <p>InMemoryStorage is a simple in-memory storage for sessions. It uses a TTLCache to store sessions with a time-to-live.</p>"},{"location":"api/session/#aspyx_service.session.SessionManager.create_session","title":"<code>create_session(*args, **kwargs)</code>","text":"<p>create a session given the arguments (usually a token, etc.) Args:     args: rest args     kwargs: keyword args</p> <p>Returns:</p> Type Description <code>Session</code> <p>the new session</p>"},{"location":"api/session/#aspyx_service.session.SessionManager.set_factory","title":"<code>set_factory(factory)</code>","text":"<p>set a factory function that will be used to create a concrete session Args:     factory: the function</p>"},{"location":"api/threading/","title":"Threading Module","text":"<p>A module with threading related utilities</p>"},{"location":"api/threading/#aspyx.threading.ContextLocal","title":"<code>ContextLocal(name, default=None)</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A context local value holder</p>"},{"location":"api/threading/#aspyx.threading.ContextLocal.get","title":"<code>get()</code>","text":"<p>return the current value or invoke the optional factory to compute one</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: the value associated with the current thread</p>"},{"location":"api/threading/#aspyx.threading.ContextLocal.reset","title":"<code>reset(token)</code>","text":"<p>clear the value in the current thread</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <p>the token to clear</p> required"},{"location":"api/threading/#aspyx.threading.ContextLocal.set","title":"<code>set(value)</code>","text":"<p>set a value in the current thread</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>the value</p> required <p>Returns:</p> Type Description <code>Any</code> <p>a token that can be used as an argument to <code>reset</code></p>"},{"location":"api/threading/#aspyx.threading.ThreadLocal","title":"<code>ThreadLocal(default_factory=None)</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A thread local value holder</p>"},{"location":"api/threading/#aspyx.threading.ThreadLocal.clear","title":"<code>clear()</code>","text":"<p>clear the value in the current thread</p>"},{"location":"api/threading/#aspyx.threading.ThreadLocal.get","title":"<code>get()</code>","text":"<p>return the current value or invoke the optional factory to compute one</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: the value associated with the current thread</p>"},{"location":"api/threading/#aspyx.threading.ThreadLocal.set","title":"<code>set(value)</code>","text":"<p>set a value in the current thread</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>the value</p> required"},{"location":"api/util/","title":"Util Module","text":"<p>This module provides utility functions.</p>"},{"location":"api/util/#aspyx.util.CopyOnWriteCache","title":"<code>CopyOnWriteCache(factory=None)</code>","text":"<p>               Bases: <code>Generic[K, V]</code></p> <p>cache, that clones the existing dict, whenever a new item is added, avoiding any locks</p>"},{"location":"api/util/#aspyx.util.Logger","title":"<code>Logger</code>","text":"<p>just syntactic sugar</p>"},{"location":"api/util/#aspyx.util.StringBuilder","title":"<code>StringBuilder()</code>","text":"<p>A StringBuilder is used to build a string by multiple append calls.</p>"},{"location":"api/util/#aspyx.util.StringBuilder.append","title":"<code>append(s)</code>","text":"<p>append a string to the end of the string builder</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string</p> required <p>Returns:</p> Name Type Description <code>StringBuilder</code> <code>StringBuilder</code> <p>self</p>"},{"location":"api/util/#aspyx.util.StringBuilder.clear","title":"<code>clear()</code>","text":"<p>clear the content</p>"},{"location":"api/util/#aspyx.util.get_deserializer","title":"<code>get_deserializer(typ)</code>  <code>cached</code>","text":"<p>return a function that is able to deserialize a value of the specified type</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <p>the type</p> required <p>Returns:</p>"},{"location":"api/util/#aspyx.util.get_serializer","title":"<code>get_serializer(typ)</code>  <code>cached</code>","text":"<p>return a function that is able to deserialize a value of the specified type</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <p>the type</p> required <p>Returns:</p>"},{"location":"index/aop/","title":"AOP","text":"<p>It is possible to define different aspects, that will be part of method calling flow. This logic fits nicely in the library, since the DI framework controls the instantiation logic and can handle aspects within a regular post processor. </p> <p>Advice classes need to be part of classes that add a <code>@advice()</code> decorator and can define methods that add aspects.</p> <pre><code>@advice\nclass SampleAdvice:\n    def __init__(self):  # could inject dependencies\n        pass\n\n    @before(methods().named(\"hello\").of_type(Foo))\n    def call_before(self, invocation: Invocation):\n        # arguments: invocation.args and invocation.kwargs\n        ...\n\n     @after(methods().named(\"hello\").of_type(Foo))\n    def call_after(self, invocation: Invocation):\n        # arguments: invocation.args and invocation.kwargs\n        ...\n\n    @error(methods().named(\"hello\").of_type(Foo))\n    def call_error(self, invocation: Invocation):\n         # error: invocation.exception\n        ...\n\n    @around(methods().named(\"hello\"))\n    def call_around(self, invocation: Invocation):\n        try:\n            ...\n            return invocation.proceed()  # will leave a result in invocation.result or invocation.exception in case of an exception\n        finally:\n            ...\n</code></pre> <p>Different aspects - with the appropriate decorator - are possible:</p> <ul> <li><code>before</code>    methods that will be executed prior to the original method</li> <li><code>around</code>    methods that will be executed around to the original method allowing you to add side effects or even modify parameters.</li> <li><code>after</code>    methods that will be executed after to the original method</li> <li><code>error</code>    methods that will be executed in case of a caught exception</li> </ul> <p>The different aspects can be supplemented with an <code>@order(&lt;prio&gt;)</code> decorator that controls the execution order based on the passed number. Smaller values get executed first. </p> <p>All methods are expected to have single <code>Invocation</code> parameter, that stores</p> <ul> <li><code>func</code> the target function</li> <li><code>args</code> the supplied args ( including the <code>self</code> instance as the first element)</li> <li><code>kwargs</code> the keywords args</li> <li><code>result</code> the result ( initially <code>None</code>)</li> <li><code>exception</code> a possible caught exception ( initially <code>None</code>)</li> </ul> <p>\u26a0\ufe0f Attention: It is essential for <code>around</code> methods to call <code>proceed()</code> on the invocation, which will call the next around method in the chain and finally the original method.</p> <p>If the <code>proceed</code> is called with parameters, they will replace the original parameters! </p> <p>Example: Parameter modifications</p> <pre><code>@around(methods().named(\"say\"))\ndef call_around(self, invocation: Invocation):\n    return invocation.proceed(invocation.args[0], invocation.args[1] + \"!\") # 0 is self!\n</code></pre> <p>The argument list to the corresponding decorators control which methods are targeted by the advice.</p> <p>A fluent interface is used describe the mapping.  The parameters restrict either methods or classes and are constructed by a call to either <code>methods()</code> or <code>classes()</code>.</p> <p>Both add the fluent methods:</p> <ul> <li><code>of_type(type: Type)</code>    defines the matching classes</li> <li><code>named(name: str)</code>    defines method or class names</li> <li><code>that_are_async()</code>    defines async methods</li> <li><code>matches(re: str)</code>    defines regular expressions for methods or classes</li> <li><code>decorated_with(type: Type)</code>    defines decorators on methods or classes</li> </ul> <p>The fluent methods <code>named</code>, <code>matches</code> and <code>of_type</code> can be called multiple times!</p> <p>Example: react on both <code>transactional</code> decorators on methods or classes</p> <pre><code>@advice\nclass TransactionAdvice:\n    def __init__(self):\n        pass\n\n    @around(methods().decorated_with(transactional), classes().decorated_with(transactional))\n    def establish_transaction(self, invocation: Invocation):\n        ...\n</code></pre> <p>With respect to async methods, you need to make sure, to replace a <code>proceed()</code> with a <code>await proceed_async()</code> to have the overall chain async!</p>"},{"location":"index/configuration/","title":"Configuration","text":"<p>It is possible to inject configuration values, by decorating methods with <code>@inject-value(&lt;name&gt;)</code> given a configuration key.</p> <pre><code>@injectable()\nclass Foo:\n    @inject_value(\"HOME\")\n    def inject_home(self, os: str):\n        ...\n</code></pre> <p>If required type coercion will be applied.</p> <p>Configuration values are managed centrally using a <code>ConfigurationManager</code>, which aggregates values from various configuration sources that are defined as follows.</p> <pre><code>class ConfigurationSource(ABC):\n    @inject()\n    def set_manager(self, manager: ConfigurationManager):\n        manager._register(self)\n\n    @abstractmethod\n    def load(self) -&gt; dict:\n       pass\n</code></pre> <p>The <code>load</code> method is able to return a tree-like structure by returning a <code>dict</code>.</p> <p>Configuration variables are retrieved with the method</p> <pre><code>def get(self, path: str, type: Type[T], default : Optional[T]=None) -&gt; T\n</code></pre> <ul> <li><code>path</code>   a '.' separated path</li> <li><code>type</code>   the desired type</li> <li><code>default</code>   a default, if no value is registered</li> </ul> <p>Sources can be added dynamically by registering them.</p> <p>Example:</p> <pre><code>@injectable()\nclass SampleConfigurationSource(ConfigurationSource):\n    def load(self) -&gt; dict:\n        return {\n            \"a\": 1, \n            \"b\": {\n                \"d\": \"2\", \n                \"e\": 3, \n                \"f\": 4\n                }\n            }\n</code></pre> <p>Two specific source are already implemented:</p> <ul> <li><code>EnvConfigurationSource</code>    reads the os environment variables</li> <li><code>YamlConfigurationSource</code>    reads a specific yaml file</li> </ul> <p>Typically you create the required configuration sources in an module, e.g.</p> <pre><code>@module()\nclass SampleModule:\n    @create()\n    def create_env_source(self) -&gt; EnvConfigurationSource:\n        return EnvConfigurationSource()\n\n    @create()\n    def create_yaml_source(self) -&gt; YamlConfigurationSource:\n        return YamlConfigurationSource(\"config.yaml\")\n</code></pre>"},{"location":"index/environment/","title":"Environment","text":"<p>Different mechanisms are available that make classes eligible for injection</p>"},{"location":"index/environment/#class","title":"Class","text":"<p>Any class annotated with <code>@injectable</code> is eligible for injection</p> <p>Example: </p> <p><pre><code>@injectable()\nclass Foo:\n    def __init__(self):\n        pass\n</code></pre> If the class defines a constructor, all parameters - which are expected to be registered as well - will be injected automatically.</p> <p>The decorator accepts the keyword arguments</p> <ul> <li><code>eager : boolean</code>   if <code>True</code>, the container will create the instances automatically while booting the environment. This is the default.</li> <li><code>scope: str</code>   the name of a - registered - scope which will determine how often instances will be created.</li> </ul> <p>The following scopes are implemented out of the box:</p> <ul> <li><code>singleton</code>    objects are created once inside an environment and cached. This is the default.</li> <li><code>request</code>    objects are created on every injection request</li> <li><code>thread</code>    objects are created and cached with respect to the current thread.</li> </ul> <p>Other scopes - e.g. session related scopes - can be defined dynamically. Please check the corresponding chapter.</p>"},{"location":"index/environment/#class-factory","title":"Class Factory","text":"<p>Classes that implement the <code>Factory</code> base class and are annotated with <code>@factory</code> will register the appropriate classes returned by the <code>create</code> method.</p> <p>Example:  <pre><code>@factory()\nclass TestFactory(Factory[Foo]):\n    def create(self) -&gt; Foo:\n        return Foo()\n</code></pre></p> <p><code>@factory</code> accepts the same arguments as <code>@injectable</code></p>"},{"location":"index/environment/#method","title":"Method","text":"<p>Any <code>injectable</code> can define methods decorated with <code>@create()</code>, that will create appropriate instances.</p> <p>Example:  <pre><code>@injectable()\nclass Foo:\n    @create(scope=\"request\")\n    def create(self) -&gt; Baz:\n        return Baz()\n</code></pre></p> <p><code>@create</code>accepts the same arguments as <code>@injectable</code></p> <p>The respective method can have any number of additional - injectable - arguments. This is handy, if the parameters are either required, or just to express a dependency, that will influence the order of instantiation.</p> <p>Example: <pre><code>@module(imports=[ServiceModule])\nclass Module:\n    @create()\n    def create_yaml_source(self) -&gt; YamlConfigurationSource:\n        return YamlConfigurationSource(f\"{Path(__file__).parent}/config.yaml\")\n\n    @create()\n    def create_registry(self, source: YamlConfigurationSource) -&gt; ConsulComponentRegistry:\n        return ConsulComponentRegistry(Server.port, consul.Consul(host=\"localhost\", port=8000))\n</code></pre> This will make sure, that the service classes already can access the yaml properties!</p>"},{"location":"index/environment/#conditional","title":"Conditional","text":"<p>All <code>@injectable</code> declarations can be supplemented with </p> <pre><code>@conditional(&lt;condition&gt;, ..., &lt;condition&gt;)\n</code></pre> <p>decorators that act as filters in the context of an environment.</p> <p>Valid conditions are created by:</p> <ul> <li><code>requires_class(clazz: Type)</code>   the injectable is valid, if the specified class is registered as well.</li> <li><code>requires_feature(feature: str)</code>   the injectable is valid, if the environment defines the specified feature.</li> </ul>"},{"location":"index/environment/#environment_1","title":"Environment","text":""},{"location":"index/environment/#definition","title":"Definition","text":"<p>An <code>Environment</code> is the container that manages the lifecycle of objects.  The set of classes and instances is determined by a  constructor type argument called <code>module</code>.</p> <p>Example:  <pre><code>@module()\nclass SampleModule:\n    pass\n</code></pre></p> <p>A module is a regular injectable class decorated with <code>@module</code> that controls the discovery of injectable classes, by filtering classes according to their module location relative to this class.    All eligible classes, that are implemented in the containing module or in any submodule will be managed.</p> <p>In a second step the real container - the environment - is created based on a module:</p> <p>Example:  <pre><code>environment = Environment(SampleModule)\n</code></pre></p> <p>The container will import the module and its children automatically. No need to add artificial import statements!</p> <p>By adding the parameter <code>features: list[str]</code>, it is possible to filter injectables by evaluating the corresponding <code>@conditional</code> decorators.</p> <p>Example:  <pre><code>@injectable()\n@conditional(requires_feature(\"dev\"))\nclass DevOnly:\n     pass\n\n@module()\nclass SampleModule():\n    pass\n\nenvironment = Environment(SampleModule, features=[\"dev\"])\n</code></pre></p> <p>By adding an <code>imports: list[Type]</code> parameter, specifying other environment types, it will register the appropriate classes recursively.</p> <p>Example:  <pre><code>@module()\nclass SampleModule(imports=[OtherModule]):\n    def __init__(self):\n        pass\n</code></pre></p> <p>Another possibility is to add a parent environment as an <code>Environment</code> constructor parameter</p> <p>Example:  <pre><code>rootEnvironment = Environment(RootModule)\n\nenvironment = Environment(SampleModule, parent=rootEnvironment)\n</code></pre></p> <p>The difference is, that in the first case, class instances of imported modules will be created in the scope of the own environment, while in the second case, it will return instances managed by the parent.</p> <p>The method</p> <p><code>shutdown()</code></p> <p>is used when a container is not needed anymore. It will call any <code>on_destroy()</code> of all created instances.</p>"},{"location":"index/environment/#retrieval","title":"Retrieval","text":"<pre><code>def get(type: Type[T]) -&gt; T\n</code></pre> <p>is used to retrieve object instances. Depending on the respective scope it will return either cached instances or newly instantiated objects.</p> <p>The container knows about class hierarchies and is able to <code>get</code> base classes, as long as there is only one implementation. </p> <p>In case of ambiguities, it will throw an exception.</p> <p>Note that a base class are not required to be annotated with <code>@injectable</code>, as this would mean, that it could be created on its own as well. ( Which is possible as well, btw. ) </p>"},{"location":"index/environment/#instantiation-logic","title":"Instantiation logic","text":"<p>Constructing a new instance involves a number of steps executed in this order</p> <ul> <li>Constructor call   the constructor is called with the resolved parameters</li> <li>Advice injection   All methods involving aspects are updated</li> <li>Lifecycle methods    different decorators can mark methods that should be called during the lifecycle ( here the construction ) of an instance.   These are various injection possibilities as well as an optional final <code>on_init</code> call</li> <li>PostProcessors   Any custom post processors, that can add side effects or modify the instances</li> </ul>"},{"location":"index/environment/#injection-methods","title":"Injection methods","text":"<p>Different decorators are implemented, that call methods with computed values</p> <ul> <li><code>@inject</code>    the method is called with all resolved parameter types ( same as the constructor call)</li> <li><code>@inject_environment</code>    the method is called with the creating environment as a single parameter</li> <li><code>@inject_value()</code>    the method is called with a resolved configuration value. Check the corresponding chapter</li> </ul> <p>Example: <pre><code>@injectable()\nclass Foo:\n    @inject_environment()\n    def set_environment(self, env: Environment):\n        ...\n\n    @inject()\n    def set(self, baz: Baz) -&gt; None:\n        ...\n</code></pre></p>"},{"location":"index/environment/#lifecycle-methods","title":"Lifecycle methods","text":"<p>It is possible to mark specific lifecyle methods. </p> <ul> <li><code>@on_init()</code>     called after the constructor and all other injections.</li> <li><code>@on_running()</code>     called after an environment has initialized completely ( e.g. created all eager objects ).</li> <li><code>@on_destroy()</code>     called during shutdown of the environment</li> </ul>"},{"location":"index/environment/#post-processors","title":"Post Processors","text":"<p>As part of the instantiation logic it is possible to define post processors that execute any side effect on newly created instances.</p> <p>Example:  <pre><code>@injectable()\nclass SamplePostProcessor(PostProcessor):\n    def process(self, instance: object, environment: Environment):\n        print(f\"created a {instance}\")\n</code></pre></p> <p>Any implementing class of <code>PostProcessor</code> that is eligible for injection will be called by passing the new instance.</p> <p>Note that a post processor will only handle instances after its own registration.</p> <p>As injectables within a single file will be handled in the order as they are declared, a post processor will only take effect for all classes after its declaration!</p>"},{"location":"index/environment/#custom-scopes","title":"Custom scopes","text":"<p>As explained, available scopes are \"singleton\" and \"request\".</p> <p>It is easily possible to add custom scopes by inheriting the base-class <code>Scope</code>, decorating the class with <code>@scope(&lt;name&gt;)</code> and overriding the method <code>get</code></p> <pre><code>def get(self, provider: AbstractInstanceProvider, environment: Environment, argProvider: Callable[[],list]):\n</code></pre> <p>Arguments are:</p> <ul> <li><code>provider</code> the actual provider that will create an instance</li> <li><code>environment</code>the requesting environment</li> <li><code>argProvider</code> a function that can be called to compute the required arguments recursively</li> </ul> <p>Example: The simplified code of the singleton provider ( disregarding locking logic )</p> <pre><code>@scope(\"singleton\")\nclass SingletonScope(Scope):\n    # constructor\n\n    def __init__(self):\n        super().__init__()\n\n        self.value = None\n\n    # override\n\n    def get(self, provider: AbstractInstanceProvider, environment: Environment, argProvider: Callable[[],list]):\n        if self.value is None:\n            self.value = provider.create(environment, *argProvider())\n\n        return self.value\n</code></pre>"},{"location":"index/event/","title":"Eventing","text":""},{"location":"index/event/#introduction","title":"Introduction","text":"<p>As we already covered the foundation for microservices, only one aspect is missing for enterprise software: Asynchronous communication involving queues.</p> <p>It's pretty simple to have a working example ready in Python using some of the low-level libraries related to stomp or amqp, but the missing thing always is an abstraction layer on top to hide the technical details.</p> <p>From a programmer perspective i essentially need a payload object, a listener and some means to define the routing logic. I really shouldn't have to bother with connections, messages, serialization and deserialization logic, threads, exception handling, etc.</p> <p>Let's look at a simple example, what the result looks like:</p> <p>Example: </p> <pre><code>@dataclass\n@event()\nclass HelloEvent:\n    world: str\n\n@event_listener(HelloEvent)\nclass HelloEventListener(EventListener[HelloEvent]):\n    # constructor\n\n    def __init__(self):\n        pass\n\n    # implement\n\n    def on(self, event: HelloEvent):\n       ...\n\nenvironment = ...\nevent_manager = environment.get(EventManager)\nevent_manager.send_event(HelloEvent(\"world\"))\n</code></pre> <p>Not bad, huh?</p>"},{"location":"index/event/#features","title":"Features","text":"<ul> <li>Support for any pydantic model or dataclass as events</li> <li>Pluggable transport protocol, currently supporting AMQP and Stomp.</li> <li>Possibility to pass headers to events</li> <li>Event interceptors on the sending and receiving side ( e.g. session capturing )</li> </ul> <p>Let's look at the details:</p>"},{"location":"index/event/#api","title":"API","text":""},{"location":"index/event/#event","title":"Event","text":"<p>An event is a dataclass or pydantic model, annotated with <code>@event()</code></p> <p>Parameters are:</p> <ul> <li><code>name=\"\"</code> name of the event, if not specified the class name is used.</li> <li><code>durable=False</code> if <code>True</code>, the provider will try to create a persistent queue.</li> </ul> <p>The name attribute will be used as a queue name!</p>"},{"location":"index/event/#eventlistener","title":"EventListener","text":"<p>An event listener derives from the base-class <code>EventListener</code> with a generic argument specifying the handled event type and are decorated with <code>@event_listener(...)</code>.</p> <p>Parameters are:</p> <ul> <li><code>name=\"\"</code> name of the listener, if not specified the class name is used.</li> <li><code>per_process=False</code> if <code>True</code>, the event will be dispatched all identical listeners, that run inside a cluster.</li> </ul> <p>Listeners are injectable objects.</p> <p>Currently, <code>on</code> is a sync method only.</p>"},{"location":"index/event/#envelopepipeline","title":"EnvelopePipeline","text":"<p>An envelope pipeline is something like an interceptor that both covers the sending and receiving side.</p> <p>It is declared as:</p> <p><pre><code>class EnvelopePipeline(ABC):\n    @abstractmethod\n    def send(self, envelope: EventManager.Envelope, event_descriptor: EventManager.EventDescriptor):\n        pass\n\n    @abstractmethod\n    def handle(self, envelope: EventManager.Envelope, event_listener_descriptor: EventManager.EventListenerDescriptor):\n        pass\n</code></pre> with envelope being a wrapper around the event, with additional possibilities to set and retrieve header information. </p> <pre><code>class Envelope(ABC):\n    @abstractmethod\n    def get_body(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def set(self, key: str, value: str):\n        pass\n\n    @abstractmethod\n    def get(self, key: str) -&gt; str:\n        pass\n</code></pre> <p>The purpose is to give the programmer the chance to set and retrieve meta data to an event. Think of passing and retrieving a session id, that will be used to establish a session context.</p> <p>Concrete pipelines are decorate with <code>@envelope_pipeline()</code> and are regular injectable objects.</p>"},{"location":"index/event/#eventmanager","title":"EventManager","text":"<p>The central class is the <code>EventManager</code> that offers the single API method</p> <pre><code>def send_event(self, event: Any)-&gt; None\n</code></pre> <p>The constructor expects an argument <code>provider: EnvironmentManager.Provider</code> that contains the technical queuing implementation.</p>"},{"location":"index/event/#providers","title":"Providers","text":"<p>A provider encapsulates the technical queuing details based on existing 3rd party libs. As different technologies offer different possibilities, some of the logical parameters -<code>durable</code>, <code>per_process</code> - may not be considered! </p>"},{"location":"index/event/#amqp","title":"AMQP","text":"<p>The class <code>AMQProvider</code> is based on the proton library utilizing the AMQ protocol.</p> <p>The constructor accepts:</p> <ul> <li><code>server_name: str</code> a unique name identifying a specific server. Typically a name including the host and some port.</li> <li><code>host=\"localhost\"</code> the url of teh amq server ( e.g. Artemis )</li> <li><code>port=61616</code> the port of the server</li> <li><code>user = \"\"</code> the user name</li> <li><code>password = \"\"</code> the password</li> </ul> <p>If we think of an Artemis address model, this is how it is applied:</p> <ul> <li>addresses are event names</li> <li>a queue name is defined as <code>&lt;event-name&gt;::&lt;listener-name&gt;[-&lt;server-name&gt;]</code></li> </ul> <p>The server name is appended, if <code>per_process</code> is <code>True</code>, guaranteeing the even in clusters every server receives the corresponding events!</p>"},{"location":"index/event/#version-history","title":"Version History","text":"<ul> <li>0.9.0: Initial version</li> </ul>"},{"location":"index/exceptions/","title":"Exceptions","text":"<p>The class <code>ExceptionManager</code> is used to collect dynamic handlers for specific exceptions and is able to dispatch to the concrete functions given a specific exception.</p> <p>The handlers are declared by decorating a class with <code>@exception_handler</code> and decorating specific methods with <code>@handle</code></p> <p>Example:</p> <pre><code>class DerivedException(Exception):\n    def __init__(self):\n        pass\n\n\n@module()\nclass SampleModule:\n    @create()\n    def create_exception_manager(self) -&gt; ExceptionManager:\n        return ExceptionManager()\n\n\n@injectable()\n@exception_handler()\nclass TestExceptionHandler:\n    @handle()\n    def handle_derived_exception(self, exception: DerivedException):\n        ExceptionManager.proceed()\n\n    @handle()\n    def handle_exception(self, exception: Exception):\n        pass\n\n    @handle()\n    def handle_base_exception(self, exception: BaseException):\n        pass\n\n\n@advice\nclass ExceptionAdvice:\n    def __init__(self, exceptionManager: ExceptionManager):\n        self.exceptionManager = exceptionManager\n\n    @error(methods().of_type(Service))\n    def handle_error(self, invocation: Invocation):\n        self.exceptionManager.handle(invocation.exception)\n\n\nenvironment = Environment(SampleModule)\n\nenvironment.read(ExceptionManager).handle(DerivedException())\n</code></pre> <p>The exception maanger will first call the most appropriate method. </p> <p>Any </p> <p><code>ExceptionManager.proceed()</code> </p> <p>will in turn call the next most applicable method ( if available).</p> <p>Together with a simple around advice we can now add exception handling to any method:</p> <p>Example: <pre><code>@injectable()\nclass Service:\n    def throw(self):\n        raise DerivedException()\n\n@advice\nclass ExceptionAdvice:\n    def __init__(self, exception_manager: ExceptionManager):\n        self.exception_manager = exception_manager\n\n    @error(methods().of_type(Service))\n    def handle_error(self, invocation: Invocation):\n        self.exception_manager.handle(invocation.exception)\n</code></pre></p>"},{"location":"index/installation/","title":"Installation","text":"<p>Just install from PyPI with </p> <p><code>pip install aspyx</code></p> <p>The library is tested with all Python version &gt;= 3.9</p>"},{"location":"index/introduction/","title":"Motivation","text":"<p>While working on AI-related projects in Python, I was looking for a dependency injection (DI) framework. After evaluating existing options, my impression was that the most either lacked key features \u2014 such as integrated AOP \u2014 or had APIs that felt overly technical and complex, which led me to develop a library on my own with the following goals</p> <ul> <li>bring both DI and AOP features together in a lightweight library,</li> <li>be as minimal invasive as possible,</li> <li>offering mechanisms to easily extend and customize features without touching the core,</li> <li>while still offering a simple and readable api that doesnt overwhelm developers and keeps the initial learning curve low.</li> </ul> <p>The AOP integration, in particular, makes a lot of sense because:</p> <ul> <li>Aspects typically require context, which is naturally provided through DI,</li> <li>And they should only apply to objects managed by the container, rather than acting globally.</li> </ul>"},{"location":"index/introduction/#overview","title":"Overview","text":"<p>Aspyx is a lightweight Python library - just about 2t loc - that provides both Dependency Injection (DI) and Aspect-Oriented Programming (AOP) support.</p> <p>The following features are supported:</p> <ul> <li>constructor and setter injection</li> <li>injection of configuration variables</li> <li>possibility to define custom injections</li> <li>post processors</li> <li>support for factory classes and methods</li> <li>support for eager and lazy construction</li> <li>support for scopes singleton, request and thread</li> <li>possibility to add custom scopes</li> <li>conditional registration of classes and factories ( aka profiles in spring )</li> <li>lifecycle events methods <code>on_init</code>, <code>on_destroy</code>, <code>on_running</code></li> <li>Automatic discovery and bundling of injectable objects based on their module location, including support for recursive imports</li> <li>Instantiation of one or possible more isolated container instances \u2014 called environments \u2014 each managing the lifecycle of a related set of objects,</li> <li>Support for hierarchical environments, enabling structured scoping and layered object management.</li> </ul> <p>With respect to AOP:</p> <ul> <li>support for before, around, after and error aspects </li> <li>simple fluent interface to specify which methods are targeted by an aspect</li> <li>sync and async method support</li> </ul> <p>The library is thread-safe and heavily performance optimized as most of the runtime information is precomputed and cached!</p> <p>Let's look at a simple example</p> <pre><code>from aspyx.di import injectable, on_init, on_destroy, module, Environment\n\n\n@injectable()\nclass Foo:\n    def hello(self, msg: str):\n        print(f\"hello {msg}\")\n\n\n@injectable()  # eager and singleton by default\nclass Bar:\n    def __init__(self, foo: Foo):  # will inject the Foo dependency\n        self.foo = foo\n\n    @on_init()  # a lifecycle callback called after the constructor and all possible injections\n    def init(self):\n        ...\n\n\n# this class will register all - specifically decorated - classes and factories in the own module\n# In this case Foo and Bar\n\n@module()\nclass SampleEnvironment:\n    pass\n\n\n# create environment\n\nenvironment = Environment(SampleEnvironment)\n\n# fetch an instance\n\nbar = environment.get(Bar)\n\nbar.foo.hello(\"world\")\n</code></pre> <p>The concepts should be pretty familiar as well as the names as they are inspired by both Spring and Angular.</p> <p>Let's have some fun and add some aspects...</p> <pre><code>@advice\nclass SampleAdvice:\n    def __init__(self): # could inject additional stuff\n        pass\n\n    @before(methods().named(\"hello\").of_type(Foo))\n    def call_before(self, invocation: Invocation):\n        ...\n\n    @error(methods().named(\"hello\").of_type(Foo))\n    def call_error(self, invocation: Invocation):\n        ... # exception accessible in invocation.exception\n\n    @around(methods().named(\"hello\"))\n    def call_around(self, invocation: Invocation):\n        ...\n        return invocation.proceed()\n</code></pre> <p>Especially the around and error aspects are usefull. Think of transactional support or general exception handling logic.</p> <p>While features like DI and AOP are often associated with enterprise applcations, this example hopefully demonstrates that they work just as well in small- to medium-sized projects\u2014without introducing significant overhead\u2014while still providing powerful tools for achieving clean architecture, resulting in maintainable and easily testable code.</p>"},{"location":"index/reflection/","title":"Reflection","text":"<p>As the library heavily relies on type introspection of classes and methods, a utility class <code>TypeDescriptor</code> is available that covers type information on classes. </p> <p>After being instantiated with</p> <pre><code>TypeDescriptor.for_type(&lt;type&gt;)\n</code></pre> <p>it offers the methods</p> <ul> <li><code>get_methods(local=False)</code>    return a list of either local or overall methods</li> <li><code>get_method(name: str, local=False)</code>    return a single either local or overall method</li> <li><code>has_decorator(decorator: Callable) -&gt; bool</code>    return <code>True</code>, if the class is decorated with the specified decorator</li> <li><code>get_decorator(decorator) -&gt; Optional[DecoratorDescriptor]</code>    return a descriptor covering the decorator. In addition to the callable, it also stores the supplied args in the <code>args</code> property</li> </ul> <p>The returned method descriptors provide:</p> <ul> <li><code>param_types</code>    list of arg types</li> <li><code>return_type</code>    the return type</li> <li><code>has_decorator(decorator: Callable) -&gt; bool</code>     return <code>True</code>, if the method is decorated with the specified decorator</li> <li><code>get_decorator(decorator: Callable) -&gt; Optional[DecoratorDescriptor]</code>    return a descriptor covering the decorator. In addition to the callable, it also stores the supplied args in the <code>args</code> property</li> </ul> <p>The management of decorators in turn relies on another utility class <code>Decorators</code> that caches decorators.</p> <p>Whenver you define a custom decorator, you will need to register it accordingly.</p> <p>Example: <pre><code>def transactional(scope):\n    def decorator(func):\n        Decorators.add(func, transactional, scope) # also add _all_ parameters in order to cache them\n        return func\n\n    return decorator\n</code></pre></p>"},{"location":"index/service/","title":"Service","text":""},{"location":"index/service/#introduction","title":"Introduction","text":"<p>The Aspyx service library is built on top of the DI core framework and adds a microservice based architecture, that lets you deploy, discover and call services with different remoting protocols and pluggable discovery services.</p> <p>The basic design consists of four different concepts:</p> <p>Service</p> <p>defines a group of methods that can be called either locally or remotely.    These methods represent the functional interface exposed to clients \u2014 similar to an interface in traditional programming</p> <p>Component</p> <p>a component bundles one or more services and declares the channels (protocols) used to expose them.   Think of a component as a deployment unit or module.</p> <p>Component Registry </p> <p>acts as the central directory for managing available components.   It allows the framework to register, discover, and resolve components and their services.</p> <p>Channel</p> <p>is a pluggable transport layer that defines how service method invocations are transmitted and handled.</p> <p>Let's look at the \"interface\" layer first.</p> <p>Example: <pre><code>@service(name=\"test-service\", description=\"test service\")\nclass TestService(Service):\n    @abstractmethod\n    def hello(self, message: str) -&gt; str:\n        pass\n\n@component(name=\"test-component\", services =[TestService])\nclass TestComponent(Component):\n    pass\n</code></pre></p> <p>After booting the DI infrastructure with a main module we could already call a service:</p> <p>Example:</p> <pre><code>@module(imports=[ServiceModule])\nclass Module:\n    @create()\n    def create_registry(self) -&gt; ConsulComponentRegistry:\n        return ConsulComponentRegistry(Server.port, Consul(host=\"localhost\", port=8500))  # a consul based registry!\n\n\nenvironment = Environment(Module)\nservice_manager = environment.read(ServiceManager)\n\nservice = service_manager.get_service(TestService)\n\nservice.hello(\"world\")\n</code></pre> <p>The technical details are completely transparent, as a dynamic proxy encapsulates the internals.</p> <p>As we can also host implementations, lets look at this side as well:</p> <pre><code>@implementation()\nclass TestComponentImpl(AbstractComponent, TestComponent):\n    # implement Component\n\n    def get_addresses(self, port: int) -&gt; list[ChannelAddress]:\n        return [ChannelAddress(\"dispatch-json\", f\"http://{Server.get_local_ip()}:{port}\")]\n\n@implementation()\nclass TestServiceImpl(TestService):\n    def hello(self, message: str) -&gt; str:\n        return f\"hello {message}\"\n</code></pre> <p>The interesting part if the <code>get_addresses</code> method that return a list of channel addresses, that can be used to execute remote calls. In this case a channel is used that exposes a single http endpoint, that will dispatch to the correct service method. This information is registered with the appropriate component registry and is used by other processes. </p> <p>The required - <code>FastAPI</code> - infrastructure to expose those services requires:</p> <ul> <li>a <code>FastAPI</code> instance</li> <li>an injectable <code>FastAPIServer</code></li> <li>and a final <code>boot</code> call with the root module, which will return an <code>Environment</code></li> </ul> <pre><code>fast_api = FastAPI() # so you can run it with uvivorn from command-line\n\n@module(imports=[ServiceModule])\nclass Module:\n    @create()\n    def create_server(self,  service_manager: ServiceManager, component_registry: ComponentRegistry) -&gt; FastAPIServer:\n        return FastAPIServer(fastapi, service_manager, component_registry)\n\n\nenvironment = FastAPIServer.boot(Module, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Of course, service can also be called locally. In case of multiple possible channels, a keyword argument is used to  determine a specific channel. As a local channel has the name \"local\", the appropriate call is:</p> <pre><code> service = service_manager.get_service(TestService, preferred_channel=\"local\")\n</code></pre>"},{"location":"index/service/#features","title":"Features","text":"<p>The library offers:</p> <ul> <li>sync and async support</li> <li>multiple and extensible channel implementations supporting dataclasses and pydantic data models.</li> <li>ability to intercept http calls via the AOP abilities ( think of bearer tokens ) </li> <li><code>fastapi</code> based channels covering simple rest endpoints including <code>msgpack</code> support.</li> <li>thread-safe <code>httpx</code> based clients for dispatching channels and simple rest endpoint with the help of low-level decorators.</li> <li>registry implementation based on <code>consul</code></li> <li>support for configurable health checks</li> </ul> <p>As well as the DI and AOP core, all mechanisms are heavily optimized. A simple benchmark resulted in message round-trips in significantly under a ms per call.</p> <p>Let's see some details</p>"},{"location":"index/service/#service-and-component-declaration","title":"Service and Component declaration","text":"<p>Every service needs to inherit from the \"tagging interface\" <code>Service</code></p> <pre><code>@service(name=\"test-service\", description=\"test service\")\nclass TestService(Service):\n    @abstractmethod\n    def hello(self, message: str) -&gt; str:\n        pass\n</code></pre> <p>The decorator can add a name and a description. If <code>name</code> is not set, the class name converted to snake case is used.</p> <p>A component needs to derive from <code>Component</code>:</p> <pre><code>@component(services =[TestService])\nclass TestComponent(Component):\n    pass\n</code></pre> <p>The <code>services</code> argument references a list of service interfaces that are managed by this component, meaning that they all are  exposed by the same channels.</p> <p><code>Component</code> defines the abstract methods:</p> <ul> <li> <p><code>def startup(self) -&gt; None</code>    called initially after booting the system</p> </li> <li> <p><code>def shutdown(self) -&gt; None:</code>    called before shutting fown the system</p> </li> <li> <p><code>def get_addresses(self, port: int) -&gt; list[ChannelAddress]:</code>    return  a list of available <code>ChannelAddress</code>es that this component exposes</p> </li> <li> <p><code>def get_status(self) -&gt; ComponentStatus:</code>    return the status of this component ( one of the <code>ComponentStatus</code> enums <code>VIRGIN</code>, <code>RUNNING</code>, and <code>STOPPED</code>)</p> </li> <li> <p><code>async def get_health(self) -&gt; HealthCheckManager.Health:</code>    return the health status of a component implementation.</p> </li> </ul>"},{"location":"index/service/#service-and-component-implementation","title":"Service and Component implementation","text":"<p>Service implementations implement the corresponding interface and are decorated with <code>@implementation</code></p> <pre><code>@implementation()\nclass TestServiceImpl(TestService):\n    ...\n</code></pre> <p>The constructor is required since the instances are managed by the DI framework.</p> <p>Component implementations derive from the interface and the abstract base class <code>AbstractComponent</code></p> <pre><code>@implementation()\nclass TestComponentImpl(AbstractComponent, TestComponent):\n    # implement Component\n\n    def get_addresses(self, port: int) -&gt; list[ChannelAddress]:\n        return [ChannelAddress(\"dispatch-json\", f\"http://{Server.get_local_ip()}:{port}\")]\n</code></pre> <p>As a minimum you have to declare the constructor and the <code>get_addresses</code> method, that exposes channel addresses</p>"},{"location":"index/service/#health-checks","title":"Health Checks","text":"<p>Every component can declare a HTTP health endpoint and the corresponding logic to compute the current status.</p> <p>Two additional things have to be done:</p> <ul> <li>adding a <code>@health(&lt;endpoint&gt;)</code> decorator to the class</li> <li>implementing the <code>get_health()</code> method that returns a <code>HealthCheckManager.Health</code></li> </ul> <p>While you can instantiate the <code>Health</code> class directly via</p> <pre><code>HealthCheckManager.Health(HealtStatus.OK)\n</code></pre> <p>it typically makes more sense to let the system execute a number of configured checks and compute the overall result automatically.</p> <p>For this purpose injectable classes can be decorated with <code>@health_checks()</code> that contain methods in turn decorated with <code>@health_check</code></p> <p>Example:</p> <pre><code>@health_checks()\n@injectable()\nclass Checks:\n    @health_check(fail_if_slower_than=1)\n    def check_performance(self, result: HealthCheckManager.Result):\n        ... # should be done in under a second\n\n    @health_check(name=\"check\", cache=10)\n    def check(self, result: HealthCheckManager.Result):\n        ok = ...\n        result.set_status(if ok HealthStatus.OK else HealthStatus.ERROR)\n</code></pre> <p>The methods are expected to have a single parameter of type <code>HealthCheckManager.Result</code> that can be used to set the status including detail information with</p> <pre><code>set_status(status: HealthStatus, details = \"\")\n</code></pre> <p>When called, the default is already <code>OK</code>.</p> <p>The decorator accepts a couple of parameters:</p> <ul> <li><code>fail_if_slower_than=0</code>     time in <code>s</code> that the check is expected to take as a maximum. As soon as the time is exceeded, the status is set to <code>ERROR</code></li> <li><code>cache</code>    time in 's' that the last result is cached. This is done in order to prevent health-checks putting even more strain on a heavily used system.</li> </ul>"},{"location":"index/service/#service-manager","title":"Service Manager","text":"<p><code>ServiceManager</code> is the central class used to retrieve service proxies.</p> <pre><code>def get_service(self, service_type: Type[T], preferred_channel=\"\") -&gt; T\n</code></pre> <ul> <li><code>type</code> is the requested service interface</li> <li><code>preferred_channel</code> the name of the preferred channel.</li> </ul> <p>If not specified, the first registered channel is used, which btw. is a local channel - called <code>local</code> -  in case of implementing services.</p> <p>The default can be set globally with the method <code>set_preferred_channel(channel: str)</code></p> <p>Injecting services is also possible via the decorator <code>@inject_service()</code></p> <p>Example:</p> <pre><code>@inject_service()\ndef set_service(self, service: TestService)\n   self.service = service\n</code></pre> <p>The decorator accepts a <code>preferred_channel</code> keyword.</p>"},{"location":"index/service/#component-registry","title":"Component Registry","text":"<p>The component registry is the place where component implementations are registered together with their supported channel addresses. Regular health checks guarantee, that the retrieved addresses relate to healthy servers only.</p> <p>Once a client binds to a specific address, the infrastructure will notify the established channels about any changes in form of added or removed URLs, giving them the chance to react accordingly.</p> <p>In addition to a <code>LocalComponentRegistry</code> ( which is used for testing purposes ) the only implementation is</p> <p><code>ConsulComponentRegistry</code></p> <p>Constructor arguments are</p> <ul> <li><code>port: int</code> the own port</li> <li><code>consul: Consul</code> the consul instance</li> </ul> <p>Example:</p> <pre><code>ConsulComponentRegistry(Server.port, consul.Consul(host=\"localhost\", port=8500))\n</code></pre> <p>Several configuration values are respected:</p> Configuration Description Default consul.watchdog.interval Time in s, that consul is polled. 5s consul.healthcheck:interval Interval in which health checks are executed 10s consul.healthcheck:timeout Health check timeout 5s consul.healthcheck:deregister Time period after which unhealthy instances are removed 5m"},{"location":"index/service/#channels","title":"Channels","text":"<p>Channels implement the possible transport layer protocols. In the sense of a dynamic proxy, they are the invocation handlers!</p> <p>Several channels are implemented:</p> <ul> <li><code>dispatch-json</code>    channel that dispatches generic <code>Request</code> objects via a generic <code>invoke</code> POST-call</li> <li><code>dispatch-msgpack</code>    channel that dispatches generic <code>Request</code> objects via a generic <code>invoke</code> POST-call after packing the json with msgpack</li> <li><code>dispatch-protobuf</code>    channel that dispatches binary parameters via a generic <code>invoke</code> POST-call after packing the parameters with protobuf</li> <li><code>rest</code>   channel that executes regular rest-calls as defined by a couple of decorators.</li> </ul> <p>All channels react on changed URLs as provided by the component registry.</p> <p>A so called <code>URLSelector</code> is used internally to provide URLs for every single call. Two subclasses exist that offer a different logic</p> <ul> <li><code>FirstURLSelector</code> always returns the first URL of the list of possible URLs</li> <li><code>RoundRobinURLSelector</code> switches sequentially between all URLs.</li> </ul> <p>To customize the behavior, an <code>around</code> advice can be implemented easily:</p> <p>Example:</p> <pre><code>@advice\nclass ChannelAdvice:\n    @around(methods().named(\"customize\").of_type(Channel))\n    def customize_channel(self, invocation: Invocation):\n        channel = cast(Channel, invocation.args[0])\n\n        channel.select_round_robin() # or select_first_url()\n\n        return invocation.proceed()\n</code></pre> <p>Several configuration values are respected:</p> <ul> <li><code>http.timeout</code>: timeout in s. Defaults to 1</li> </ul>"},{"location":"index/service/#performance","title":"Performance","text":"<p>I benchmarked the different implementations with a recursive dataclass as an argument and return value. The avg response times - on a local server - where all below 1ms per call.</p> <ul> <li>rest calls are the slowest ( about 0.7ms )</li> <li>dispatching-json 20% faster</li> <li>dispatching-msgpack 30% faster</li> </ul> <p>The biggest advantage of the dispatching flavors is, that you don't have to worry about the additional decorators!</p>"},{"location":"index/service/#rest-calls","title":"Rest Calls","text":"<p>Invoking rest calls requires decorators and some marker annotations.</p> <p>Example:</p> <pre><code>@service()\n@rest(\"/api\")\nclass TestService(Service):\n    @get(\"/hello/{message}\")\n    def hello(self, message: str) -&gt; str:\n        pass\n\n    @post(\"/post/\")\n    def set_data(self, data: Body(Data)) -&gt; Data:\n        pass\n</code></pre> <p>The decorators <code>get</code>,  <code>put</code>,  <code>post</code> and  <code>delete</code> specify the methods.</p> <p>If the class is decorated with <code>@rest(&lt;prefix&gt;)</code>, the corresponding prefix will be appended at the beginning.</p> <p>Additional annotations are - <code>Body</code> the post body - <code>QueryParam</code>marked for query params</p> <p>You can skip the annotations, assuming the following heuristic:</p> <ul> <li>if no body is marked it will pick the first parameter which is a dataclass or a pydantic model</li> <li>all parameters which are not in the path or equal to the body are assumed to be query params.</li> </ul>"},{"location":"index/service/#intercepting-calls","title":"Intercepting calls","text":"<p>The client side HTTP calling is done with <code>httpx</code> instances of type <code>Httpx.Client</code> or <code>Httpx.AsyncClient</code>.</p> <p>To add the possibility to add interceptors - for token handling, etc. - the channel base class <code>HTTPXChannel</code> defines the methods <code>make_client()</code> and <code>make_async_client</code> that can be modified with an around advice.</p> <p>Example:</p> <pre><code>class InterceptingClient(httpx.Client):\n    # constructor\n\n    def __init__(self, *args, **kwargs):\n        self.token_provider = ...\n        super().__init__(*args, **kwargs)\n\n    # override\n\n    def request(self, method, url, *args, **kwargs):\n        headers = kwargs.pop(\"headers\", {})\n        headers[\"Authorization\"] = f\"Bearer {self.token_provider()}\"\n        kwargs[\"headers\"] = headers\n\n        return super().request(method, url, *args, **kwargs)\n\n@advice\nclass ChannelAdvice:\n    def __init__(self):\n        pass\n\n    @around(methods().named(\"make_client\").of_type(HTTPXChannel))\n    def make_client(self, invocation: Invocation):\n        return InterceptingClient()\n</code></pre>"},{"location":"index/service/#fastapi-server","title":"FastAPI server","text":"<p>In order to expose components via HTTP, the corresponding infrastructure in form of a FastAPI server needs to be setup. </p> <pre><code>fast_api = FastAPI() # so you can run it with uvicorn from command-line\n\n@module()\nclass Module:\n    @create()\n    def create_server(self,  service_manager: ServiceManager, component_registry: ComponentRegistry) -&gt; FastAPIServer:\n        return FastAPIServer(fastapi, service_manager, component_registry)\n\nenvironment = FastAPIServer.boot(Module, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>This setup will also expose all service interfaces decorated with the corresponding http decorators! No need to add any FastAPI decorators, since the mapping is already done internally! </p>"},{"location":"index/service/#session","title":"Session","text":"<p>TODO</p>"},{"location":"index/service/#authorization","title":"Authorization","text":"<p>TODO</p>"},{"location":"index/service/#implementing-channels","title":"Implementing Channels","text":"<p>To implement a new channel, you only need to derive from one of the possible base classes ( <code>Channel</code> or <code>HTTPXChannel</code> that already has a <code>httpx</code> client) and decorate it with <code>@channel(&lt;name&gt;)</code></p> <p>The main methods to implement are <code>\u00ecnvoke</code> and <code>\u00ecnvoke_async</code></p> <p>Example:</p> <pre><code>@channel(\"fancy\")\nclass FancyChannel(Channel):\n    # override\n\n    def invoke(self, invocation: DynamicProxy.Invocation):\n        return ...\n\n     async def invoke_async(self, invocation: DynamicProxy.Invocation):\n        return await ...\n</code></pre>"},{"location":"index/service/#version-history","title":"Version History","text":"<p>0.10.0</p> <ul> <li>first release version</li> </ul> <p>0.11.0</p> <ul> <li>added protobuf support</li> </ul>"},{"location":"index/session/","title":"Session","text":"<p>This module covers the concept of a - server-side - session and their lifecycle</p>"},{"location":"index/session/#session_1","title":"Session","text":"<p><code>Session</code> is a base-class for classes covering the properties of a server-side session.</p>"},{"location":"index/session/#sessionmanager","title":"SessionManager","text":"<p><code>SessionManager</code> is responsible for the lifecycle of sessions.</p>"},{"location":"index/threading/","title":"Threading","text":""},{"location":"index/threading/#threadlocal","title":"ThreadLocal","text":"<p>The class <code>ThreadLocal</code> is a simple generic wrapper around <code>threading.local</code></p> <p>After creating an instance with <code>ThreadLocal[type]()</code> you can use the methods: - <code>get(self) -&gt; Optional[T]</code> - <code>set(self, value: T) -&gt; None</code> - <code>clear(self)</code></p> <p>An optional constructor argument serves as a factory that is called in the <code>get</code> methiod whenever no value i set.</p>"},{"location":"index/threading/#contextlocal","title":"ContextLocal","text":"<p>A similar class <code>ContextLocal</code> is implemented that uses <code>ContextVar</code>s. In addition it defines a <code>use</code> method as a <code>@contextmanager</code></p>"},{"location":"index/threading/#synchronized","title":"Synchronized","text":"<p>A handy decorator <code>@synchronized</code> in combination with the respective advice is implemented that automatically synchronizes methods with a <code>RLock</code> associated with the instance.</p> <p>Example: <pre><code>@injectable()\nclass Foo:\n    @synchronized()\n    def execute_synchronized(self):\n        ...\n</code></pre></p>"},{"location":"index/versions/","title":"Version History","text":"<p>1.0.1</p> <ul> <li>some internal refactorings</li> </ul> <p>1.1.0</p> <ul> <li>added <code>@on_running()</code> callback</li> <li>added <code>thread</code> scope</li> </ul> <p>1.2.0</p> <ul> <li>added <code>YamlConfigurationSource</code></li> </ul> <p>1.3.0</p> <ul> <li>added <code>@conditional</code></li> <li>added support for <code>async</code> advices</li> </ul> <p>1.4.0</p> <ul> <li>bugfixes</li> <li>added <code>@ExceptionManager</code></li> <li> <p>1.6.1</p> </li> <li> <p>default constructor for injectables not required anymore</p> </li> </ul>"}]}